# An example for better_launch's declarative launchfiles.
# 
# The discussions over at ros discourse revealed that there was a need for 
# launchfiles that are not code-based but can be parsed offline. This is 
# better_launch's answer, based on the TOML format.
# 
# By the way, the first comment block becomes the launchfile's help text :)

# ==============================================================================
# Execute a TOML better_launch launchfile
# ==============================================================================
#
# In better_launch TOML launch files, most tables are *call tables*.
# A call table is a dictionary with a func key referring to one of the
# public BetterLaunch member functions.
# All other attributes are treated as keyword arguments to that function.
# Call tables execute in order of appearance, and their return values
# are stored under the tableâ€™s name.
# 
# ------------------------------------------------------------------------------

# Launch arguments
# ------------------------------------------------------------------------------
# Any entry outside a call table is treated as a launch argument or global 
# key. These arguments, as well as results of call tables, can be referenced
# using substitutions (similar to ROS1's $(arg X)):
#
#   $(<K>)            -> value of launch argument or call table <K>
#   $(param <N> <P>)  -> parameter <P> from node <N>
#   $(env <E> <D>)    -> environment variable <E> (default <D>)
#   $(eval <X>)       -> evaluate Python expression <X>
#
# Substitutions may be nested (inner ones resolve first).
#
# ------------------------------------------------------------------------------

# Context objects
# ------------------------------------------------------------------------------
# Functions like BetterLaunch.group or BetterLaunch.compose
# accept a children attribute (a dict of dicts). Example:
#
#   [my_composer]
#   func = "compose"
#
#   [my_composer.children.talker]
#   func = "component"
#   package = "composition"
#   plugin = "composition::Talker"
#
# Call tables may also include conditional attributes:
#   if     -> execute only if condition is true
#   unless -> execute only if condition is false
#
# ------------------------------------------------------------------------------

# Special keys
# ------------------------------------------------------------------------------
#   bl_toml_format:          TOML parser version your launch file targets.
#                            Current version: :py:data:toml_format_version.
#
#   bl_eval_mode:            Controls ${eval ...} substitutions:
#                              - "full":    regular eval
#                              - "literal": only literals (ast.literal_eval)
#                              - "none":    disable evaluation
#
#   bl_ui:                   Default for starting the UI
#   bl_join:                 Whether to join started processes
#   bl_colormode:            Default color mode
#   bl_screen_log_format:    Default terminal output format
#   bl_file_log_format:      Default file log format
#   bl_manage_foreign_nodes: Whether to show foreign nodes in the UI
#   bl_keep_alive:           Keep running after last node exits
#   bl_allow_kwargs:         Allow additional launch arguments
#
# ------------------------------------------------------------------------------

# This is where the actual launch file begins
# ------------------------------------------------------------------------------

# Any keys that are not part of a table are considered launch arguments. If a value is 
# provided their type is derived from that value. It is also possible to define launch
# arguments with a primitive type (e.g. `my_launch_arg = bool`) - in this case it will
# not have a default and must be provided by the user.

# Comments above any block become help text when run with --help.
pkg = "better_launch"

# This block will call BetterLaunch.find with the provided arguments. The result will 
# be stored in a variable called "a_simple_cube" and can be used later in substituions.
[a_simple_cube]
# Only run if pkg was defined (based on python truthiness). You can also use "unless".
if = "${pkg}"
func = "find"
package = "${pkg}"
filename = "cube.sdf"

# Blocks are executed in sequence, so we can now use the result of the previous one.
[print_me_baby]
func = "exec"
cmd = ["echo", "A simple cube can be found at ${a_simple_cube}"]
